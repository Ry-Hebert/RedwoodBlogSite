"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.createGraphQLHandler = exports.createContextHandler = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise"));

var _interopRequireWildcard2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/interopRequireWildcard"));

var _apolloServerLambda = require("apollo-server-lambda");

var _auth = require("../auth");

var _globalContext = require("../globalContext");

/**
 * We use Apollo Server's `context` option as an entry point to construct our
 * own global context.
 *
 * Context explained by Apollo's Docs:
 * Context is an object shared by all resolvers in a particular query,
 * and is used to contain per-request state, including authentication information,
 * dataloader instances, and anything else that should be taken into account when
 * resolving the query.
 */
const createContextHandler = (userContext, getCurrentUser) => {
  return async ({
    event,
    context
  }) => {
    // Prevent the Serverless function from waiting for all resources (db connections)
    // to be released before returning a reponse.
    context.callbackWaitsForEmptyEventLoop = false; // If the request contains authorization headers, we'll decode the providers that we support,
    // and pass those to the `currentUser`.

    const authContext = await (0, _auth.getAuthenticationContext)({
      event,
      context
    });

    if (authContext) {
      context.currentUser = getCurrentUser ? await getCurrentUser(authContext[0], authContext[1]) : authContext;
    }

    let customUserContext = userContext;

    if (typeof userContext === 'function') {
      // if userContext is a function, run that and return just the result
      customUserContext = await userContext({
        event,
        context
      });
    } // Sets the **global** context object, which can be imported with:
    // import { context } from '@redwoodjs/api'


    return (0, _globalContext.setContext)({ ...context,
      ...customUserContext
    });
  };
};

exports.createContextHandler = createContextHandler;

/**
 * Creates an Apollo GraphQL Server.
 *
 * ```js
 * export const handler = createGraphQLHandler({ schema, context, getCurrentUser })
 * ```
 */
const createGraphQLHandler = ({
  context,
  getCurrentUser,
  onException,
  ...options
} = {}, db) => {
  const isDevEnv = process.env.NODE_ENV !== 'production';
  const handler = new _apolloServerLambda.ApolloServer({
    // Turn off playground in production
    debug: isDevEnv,
    playground: isDevEnv,
    // Log the errors in the console
    formatError: error => {
      if (isDevEnv) {
        // I want the dev-server to pick this up!?
        // TODO: Move the error handling into a separate package
        // @ts-ignore
        _promise.default.resolve().then(() => (0, _interopRequireWildcard2.default)(require('@redwoodjs/dev-server/dist/error'))).then(({
          handleError
        }) => {
          return handleError(error.originalError);
        }).then(console.log).catch(() => {});
      }

      return error;
    },
    // Wrap the user's context function in our own
    context: createContextHandler(context, getCurrentUser),
    ...options
  }).createHandler();
  return (event, context, callback) => {
    try {
      handler(event, context, callback);
    } catch (e) {
      onException && onException(); // Disconnect from the database (recommended by Prisma), this step will be
      // removed in future releases.

      db && db.disconnect();
      throw e;
    }
  };
};

exports.createGraphQLHandler = createGraphQLHandler;