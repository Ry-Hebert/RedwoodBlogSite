"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.makeMergedSchema = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _apolloServerLambda = require("apollo-server-lambda");

var _mergeGraphqlSchemas = require("merge-graphql-schemas");

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _lodash2 = _interopRequireDefault(require("lodash.omitby"));

var rootSchema = _interopRequireWildcard(require("./rootSchema"));

const mapFieldsToService = ({
  fields = {},
  resolvers: unmappedResolvers,
  services
}) => {
  var _context;

  return (0, _reduce.default)(_context = (0, _keys.default)(fields)).call(_context, (resolvers, name) => {
    // Does the function already exist in the resolvers from the schema definition?
    if (resolvers === null || resolvers === void 0 ? void 0 : resolvers[name]) {
      return resolvers;
    } // Does a function exist in the service?


    if (services === null || services === void 0 ? void 0 : services[name]) {
      return { ...resolvers,
        // Map the arguments from GraphQL to an ordinary function a service would
        // expect.
        [name]: (root, args, context, info) => services[name](args, {
          root,
          context,
          info
        })
      };
    }

    return resolvers;
  }, unmappedResolvers);
};
/**
 * This iterates over all the schemas definitions and figures out which resolvers
 * are missing, it then tries to add the missing resolvers from the corresponding
 * service.
 */


const mergeResolversWithServices = ({
  schema,
  resolvers,
  services
}) => {
  var _context2, _context3, _context4, _context5, _context6;

  const mergedServices = (0, _lodash.default)({}, ...(0, _map.default)(_context2 = (0, _keys.default)(services)).call(_context2, name => services[name])); // Get a list of types that have fields.
  // TODO: Figure out if this would interfere with other types: Interface types, etc.`

  const typesWithFields = (0, _filter.default)(_context3 = (0, _map.default)(_context4 = (0, _filter.default)(_context5 = (0, _filter.default)(_context6 = (0, _keys.default)(schema.getTypeMap())).call(_context6, name => !(0, _startsWith.default)(name).call(name, '_'))).call(_context5, name => typeof schema.getType(name).getFields !== 'undefined')).call(_context4, name => {
    return schema.getType(name);
  })).call(_context3, type => type !== undefined && type !== null);
  const mappedResolvers = (0, _reduce.default)(typesWithFields).call(typesWithFields, (acc, type) => {
    var _context7;

    // Services export Query and Mutation field resolvers as named exports,
    // but other GraphQLObjectTypes are exported as an object that are named
    // after the type.
    // Example: export const MyType = { field: () => {} }
    let servicesForType = mergedServices;

    if (!(0, _includes.default)(_context7 = ['Query', 'Mutation']).call(_context7, type.name)) {
      servicesForType = mergedServices === null || mergedServices === void 0 ? void 0 : mergedServices[type.name];
    }

    return { ...acc,
      [type.name]: mapFieldsToService({
        fields: type.getFields(),
        resolvers: resolvers === null || resolvers === void 0 ? void 0 : resolvers[type.name],
        services: servicesForType
      })
    };
  }, {});
  return (0, _lodash2.default)({ ...resolvers,
    ...mappedResolvers
  }, v => typeof v === 'undefined');
};

const mergeResolvers = schemas => {
  var _context8;

  return (0, _lodash2.default)((0, _lodash.default)({}, ...[rootSchema.resolvers, ...(0, _map.default)(_context8 = (0, _values.default)(schemas)).call(_context8, ({
    resolvers
  }) => resolvers)]), v => typeof v === 'undefined');
};
/**
 * Merge GraphQL typeDefs and resolvers into a single schema.
 *
 * @example
 * ```js
 * const schemas = importAll('api', 'graphql')
 * const services = importAll('api', 'services')
 *
 * const schema = makeMergedSchema({
 *  schema,
 *  services: makeServices({ services }),
 * })
 * ```
 */


const makeMergedSchema = ({
  schemas,
  services,
  schemaDirectives
}) => {
  var _context9;

  const typeDefs = (0, _mergeGraphqlSchemas.mergeTypes)([rootSchema.schema, ...(0, _map.default)(_context9 = (0, _values.default)(schemas)).call(_context9, ({
    schema
  }) => schema)], {
    all: true
  });
  const schema = (0, _apolloServerLambda.makeExecutableSchema)({
    typeDefs,
    schemaDirectives
  });
  const resolvers = mergeResolversWithServices({
    schema,
    resolvers: mergeResolvers(schemas),
    services
  });
  (0, _apolloServerLambda.addResolveFunctionsToSchema)({
    schema,
    resolvers
  });
  return schema;
};

exports.makeMergedSchema = makeMergedSchema;